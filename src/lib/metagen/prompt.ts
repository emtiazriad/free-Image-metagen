import type { MetaGenControls } from "./types"; export function buildPrompt(controls: MetaGenControls) { const { titleLengthMin, titleLengthMax, descLengthMin, descLengthMax, keywordCount, keywordStyle, tone, positiveKeywords } = controls; const positiveKeywordsSection = positiveKeywords?.trim() ? \nPOSITIVE KEYWORDS TO INCLUDE:\nYou MUST incorporate these keywords/concepts where naturally appropriate: ${positiveKeywords.trim()}\n : ""; return You are an expert in image SEO, stock photography metadata, and digital asset optimization. Analyze this image and generate metadata according to STRICT character and count limits. CONTEXT: - Keyword style: ${keywordStyle} - Tone: ${tone} ${positiveKeywordsSection} OUTPUT FORMAT (use EXACTLY this format): TITLE: DESCRIPTION: ALT_TEXT: KEYWORDS: HASHTAGS: CATEGORIES: ═══════════════════════════════════════════════════════════════ MANDATORY LENGTH REQUIREMENTS — FAILURE TO MEET = REJECTION ═══════════════════════════════════════════════════════════════ TITLE REQUIREMENTS: • MINIMUM: ${titleLengthMin} characters — THIS IS CRITICAL, your title MUST reach this length • MAXIMUM: ${titleLengthMax} characters • Count EVERY character including spaces and punctuation • If your title is under ${titleLengthMin} chars, you MUST add more descriptive adjectives, context, or details • STRATEGY: Include setting, mood, style, purpose, and visual details to reach minimum • Example: "Ocean sunset" (12 chars) → "Breathtaking golden sunset over calm ocean waves reflecting warm amber light perfect for travel and nature photography backgrounds" (${Math.min(130, titleLengthMax)} chars) DESCRIPTION REQUIREMENTS: • MINIMUM: ${descLengthMin} characters — THIS IS CRITICAL, your description MUST reach this length • MAXIMUM: ${descLengthMax} characters • Count EVERY character including spaces and punctuation • If under ${descLengthMin} chars, ADD: visual details, colors, textures, mood, use cases, applications, context • STRATEGY: Describe what you see, the atmosphere, potential uses, target audience, and style in detail • Write in flowing sentences, not bullet points KEYWORDS REQUIREMENTS: • You MUST generate EXACTLY ${keywordCount} keywords — not one more, not one less • Count your keywords before outputting! • Format: comma-separated, single words or 2-3 word phrases • Each keyword must be unique (no duplicates or near-duplicates) • Include: subject, style, mood, colors, concepts, use cases, related terms ═══════════════════════════════════════════════════════════════ OTHER RULES ═══════════════════════════════════════════════════════════════ • ALT_TEXT: Single sentence describing the image for accessibility (50-150 chars) • HASHTAGS: 10-15 relevant hashtags with # prefix, space-separated • CATEGORIES: 2-5 categories, comma-separated (e.g., "Nature, Travel, Landscape") • Every field MUST be present and NON-EMPTY • Do NOT use placeholders like "N/A" or leave any field blank • Do NOT add markdown, bullet points, or extra formatting • Return ONLY the fields in the exact format above; } export function buildConstraintRepairPrompt( controls: MetaGenControls, issues: { titleTooShort?: boolean; titleTooLong?: boolean; descTooShort?: boolean; descTooLong?: boolean; keywordsTooFew?: boolean; keywordsTooMany?: boolean }, currentOutput: { title?: string; description?: string; keywords?: string } ) { const { titleLengthMin, titleLengthMax, descLengthMin, descLengthMax, keywordCount } = controls; const repairs: string[] = []; if (issues.titleTooShort || issues.titleTooLong) { const currentLen = currentOutput.title?.length ?? 0; const issue = issues.titleTooShort ? TOO SHORT (${currentLen} chars, need ${titleLengthMin}-${titleLengthMax}) : TOO LONG (${currentLen} chars, need ${titleLengthMin}-${titleLengthMax}); repairs.push(TITLE: ${issue} — ${issues.titleTooShort ? 'EXPAND with more descriptive words' : 'SHORTEN while keeping meaning'}); } if (issues.descTooShort || issues.descTooLong) { const currentLen = currentOutput.description?.length ?? 0; const issue = issues.descTooShort ? TOO SHORT (${currentLen} chars, need ${descLengthMin}-${descLengthMax}) : TOO LONG (${currentLen} chars, need ${descLengthMin}-${descLengthMax}); repairs.push(DESCRIPTION: ${issue} — ${issues.descTooShort ? 'ADD more detail and context' : 'TRIM while preserving key information'}); } if (issues.keywordsTooFew || issues.keywordsTooMany) { const currentCount = currentOutput.keywords?.split(',').filter(k => k.trim()).length ?? 0; const issue = issues.keywordsTooFew ? TOO FEW (${currentCount} keywords, need exactly ${keywordCount}) : TOO MANY (${currentCount} keywords, need exactly ${keywordCount}); repairs.push(KEYWORDS: ${issue} — ${issues.keywordsTooFew ? 'ADD more relevant keywords' : 'REMOVE less relevant keywords'}); } return CONSTRAINT REPAIR — Fix the following issues: ${repairs.join('\n')} CURRENT VALUES: ${issues.titleTooShort || issues.titleTooLong ? TITLE (${currentOutput.title?.length ?? 0} chars): ${currentOutput.title} : ''} ${issues.descTooShort || issues.descTooLong ? DESCRIPTION (${currentOutput.description?.length ?? 0} chars): ${currentOutput.description} : ''} ${issues.keywordsTooFew || issues.keywordsTooMany ? KEYWORDS (${currentOutput.keywords?.split(',').filter(k => k.trim()).length ?? 0} items): ${currentOutput.keywords} : ''} OUTPUT FORMAT — Return ONLY the fields that need fixing: ${issues.titleTooShort || issues.titleTooLong ? TITLE: (must be ${titleLengthMin}-${titleLengthMax} chars) : ''} ${issues.descTooShort || issues.descTooLong ? DESCRIPTION: (must be ${descLengthMin}-${descLengthMax} chars) : ''} ${issues.keywordsTooFew || issues.keywordsTooMany ? KEYWORDS: (must be exactly ${keywordCount} items, comma-separated) : ''} CRITICAL: Count characters/keywords carefully before responding!; }
